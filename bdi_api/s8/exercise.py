from datetime import datetime
from typing import List, Optional

import requests
from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel
from sqlalchemy import Boolean, Column, DateTime, Float, Integer, String, BigInteger, create_engine, func, select
from sqlalchemy.orm import declarative_base, sessionmaker

from bdi_api.settings import DBCredentials, Settings

settings = Settings()
db_credentials = DBCredentials()

# Construct DATABASE_URL
DATABASE_URL = (
    f"postgresql+psycopg2://{db_credentials.username}:{db_credentials.password}"
    f"@{db_credentials.host}:{db_credentials.port}/{db_credentials.database}"
)

# SQLAlchemy setup (models defined here as no models.py exists)
Base = declarative_base()

class Aircraft(Base):
    __tablename__ = "aircraft_positions"
    icao = Column(String, primary_key=True)
    timestamp = Column(BigInteger, primary_key=True)  # Use BigInteger
    lat = Column(Float)
    lon = Column(Float)
    altitude_baro = Column(Integer)
    ground_speed = Column(Integer)
    emergency = Column(Boolean)

class AircraftDatabase(Base):
    __tablename__ = "aircraft_db"
    icao = Column(String, primary_key=True)
    date = Column(DateTime)
    reg = Column(String)
    manufacturer = Column(String)
    model = Column(String)
    year = Column(Integer)
    mil = Column(Boolean)
    faa_pia = Column(Boolean)
    faa_ladd = Column(Boolean)

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

# Fuel consumption data URL (remote fetch confirmed)
FUEL_CONSUMPTION_URL = (
    "https://raw.githubusercontent.com/martsec/flight_co2_analysis/main/"
    "data/aircraft_type_fuel_consumption_rates.json"
)

s8 = APIRouter(
    responses={
        status.HTTP_404_NOT_FOUND: {"description": "Not found"},
        status.HTTP_422_UNPROCESSABLE_ENTITY: {"description": "Something is wrong with the request"},
    },
    prefix="/api/s8",
    tags=["s8"],
)

class AircraftReturn(BaseModel):
    icao: str
    registration: Optional[str]
    type: Optional[str]
    owner: Optional[str]
    manufacturer: Optional[str]
    model: Optional[str]

class AircraftCO2(BaseModel):
    icao: str
    hours_flown: float
    co2: Optional[float]

@s8.get("/aircraft/", response_model=List[AircraftReturn])
def list_aircraft(num_results: int = 100, page: int = 0) -> List[AircraftReturn]:
    """List all the available aircraft, its registration and type ordered by
    icao asc FROM THE DATABASE, enriched with aircraft_db info.
    """
    with SessionLocal() as session:
        query = (
            select(
                Aircraft.icao,
                AircraftDatabase.reg.label("registration"),
                AircraftDatabase.model.label("type"),  # Using model as proxy for type
                AircraftDatabase.manufacturer,
                AircraftDatabase.model
            )
            .join(
                AircraftDatabase,
                Aircraft.icao == AircraftDatabase.icao,
                isouter=True
            )
            .distinct(Aircraft.icao)
            .order_by(Aircraft.icao.asc())
            .limit(num_results)
            .offset(page * num_results)
        )
        results = session.execute(query).all()
        return [
            AircraftReturn(
                icao=row.icao,
                registration=row.registration,
                type=row.type,
                owner=None,  # Not available in aircraft_db
                manufacturer=row.manufacturer,
                model=row.model
            )
            for row in results
        ]

@s8.get("/aircraft/{icao}/co2", response_model=AircraftCO2)
def get_aircraft_co2(icao: str, day: str) -> AircraftCO2:
    """Returns the CO2 generated by the aircraft in a given day."""
    try:
        day_dt = datetime.strptime(day, "%Y-%m-%d")
    except ValueError as e:
        raise HTTPException(
            status_code=422,
            detail="Invalid day format. Use YYYY-MM-DD"
        ) from e

    if day_dt.day != 1:
        raise HTTPException(status_code=422, detail="Data only available for the 1st of each month")

    with SessionLocal() as session:
        # Convert to Unix timestamps (seconds)
        day_start = int(day_dt.replace(hour=0, minute=0, second=0, microsecond=0).timestamp())
        day_end = int(day_dt.replace(hour=23, minute=59, second=59, microsecond=999999).timestamp())

        query = (
            select(func.count())
            .select_from(Aircraft)
            .filter(
                Aircraft.icao == icao,
                Aircraft.timestamp.between(day_start, day_end)
            )
        )
        record_count = session.execute(query).scalar() or 0
        hours_flown = (record_count * 5) / 3600  # 5 seconds per record

        # Join with aircraft_db to get model as icaotype
        aircraft = session.execute(
            select(AircraftDatabase.model)
            .join(Aircraft, Aircraft.icao == AircraftDatabase.icao)
            .filter(Aircraft.icao == icao)
            .limit(1)
        ).scalar()

        if not aircraft:
            raise HTTPException(status_code=404, detail="Aircraft not found")

        try:
            response = requests.get(FUEL_CONSUMPTION_URL, timeout=5)
            response.raise_for_status()
            fuel_data = response.json()
        except requests.RequestException:
            return AircraftCO2(icao=icao, hours_flown=hours_flown, co2=None)

        co2 = None
        if aircraft in fuel_data:
            galph = fuel_data[aircraft]["galph"]
            fuel_used_gal = galph * hours_flown
            fuel_used_kg = fuel_used_gal * 3.04
            co2_tons = (fuel_used_kg * 3.15) / 907.185
            co2 = co2_tons
        else:
            # Log or handle cases where model doesn't match fuel_data keys
            pass

        return AircraftCO2(icao=icao, hours_flown=hours_flown, co2=co2)